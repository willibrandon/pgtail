name: Release

on:
  push:
    tags:
      - 'v*'

# Permissions required for creating releases, pushing to homebrew-tap, and creating issues
permissions:
  contents: write
  issues: write

jobs:
  # Build binaries for Unix-like systems (macOS and Linux)
  build-unix:
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-14
            platform: macos
            arch: arm64
          - os: macos-15-intel
            platform: macos
            arch: x86_64
          - os: ubuntu-latest
            platform: linux
            arch: x86_64
          - os: ubuntu-24.04-arm
            platform: linux
            arch: arm64

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Install dependencies
        run: uv sync --extra dev

      - name: Build binary with Nuitka
        run: |
          uv run nuitka \
            --mode=standalone \
            --output-dir=dist \
            --output-filename=pgtail \
            --include-package=pgtail_py \
            --include-package=psutil \
            --include-package-data=certifi \
            --include-module=pgtail_py.detector_unix \
            --include-module=pgtail_py.detector_windows \
            --include-module=pgtail_py.notifier_unix \
            --include-module=pgtail_py.notifier_windows \
            --nofollow-import-to=psutil.tests \
            --python-flag=no_asserts \
            --python-flag=-m \
            --assume-yes-for-downloads \
            pgtail_py

      - name: Rename output directory
        run: |
          # Nuitka outputs to pgtail.dist/, pgtail_py.dist/, or __main__.dist/
          if [ -d "dist/pgtail.dist" ]; then
            mv dist/pgtail.dist dist/pgtail-${{ matrix.platform }}-${{ matrix.arch }}
          elif [ -d "dist/pgtail_py.dist" ]; then
            mv dist/pgtail_py.dist dist/pgtail-${{ matrix.platform }}-${{ matrix.arch }}
          elif [ -d "dist/__main__.dist" ]; then
            mv dist/__main__.dist dist/pgtail-${{ matrix.platform }}-${{ matrix.arch }}
          else
            echo "ERROR: Nuitka output directory not found"
            ls -la dist/
            exit 1
          fi

      - name: Verify binary runs
        run: |
          ./dist/pgtail-${{ matrix.platform }}-${{ matrix.arch }}/pgtail --version

      - name: Create tar.gz archive
        run: |
          cd dist
          tar -czvf pgtail-${{ matrix.platform }}-${{ matrix.arch }}.tar.gz pgtail-${{ matrix.platform }}-${{ matrix.arch }}

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: pgtail-${{ matrix.platform }}-${{ matrix.arch }}
          path: dist/pgtail-${{ matrix.platform }}-${{ matrix.arch }}.tar.gz
          retention-days: 1

  # Build binary for Windows (separate job due to different shell syntax)
  build-windows:
    runs-on: windows-latest
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Install dependencies
        run: uv sync --extra dev

      - name: Build binary with Nuitka
        run: |
          uv run nuitka `
            --mode=standalone `
            --output-dir=dist `
            --output-filename=pgtail `
            --windows-icon-from-ico=art/pgtail.ico `
            --include-package=pgtail_py `
            --include-package=psutil `
            --include-package-data=certifi `
            --include-module=pgtail_py.detector_unix `
            --include-module=pgtail_py.detector_windows `
            --include-module=pgtail_py.notifier_unix `
            --include-module=pgtail_py.notifier_windows `
            --nofollow-import-to=psutil.tests `
            --python-flag=no_asserts `
            --python-flag=-m `
            --assume-yes-for-downloads `
            pgtail_py

      - name: Rename output directory
        shell: pwsh
        run: |
          # Nuitka outputs to pgtail.dist/, pgtail_py.dist/, or __main__.dist/
          if (Test-Path "dist\pgtail.dist") {
            Move-Item "dist\pgtail.dist" "dist\pgtail-windows-x86_64"
          } elseif (Test-Path "dist\pgtail_py.dist") {
            Move-Item "dist\pgtail_py.dist" "dist\pgtail-windows-x86_64"
          } elseif (Test-Path "dist\__main__.dist") {
            Move-Item "dist\__main__.dist" "dist\pgtail-windows-x86_64"
          } else {
            Write-Error "Nuitka output directory not found"
            Get-ChildItem dist\
            exit 1
          }

      - name: Verify binary runs
        run: |
          .\dist\pgtail-windows-x86_64\pgtail.exe --version

      - name: Create ZIP archive
        shell: pwsh
        run: |
          Compress-Archive -Path "dist\pgtail-windows-x86_64" -DestinationPath "dist\pgtail-windows-x86_64.zip"

      - name: Verify ZIP extraction and executable
        shell: pwsh
        run: |
          # Extract to temp directory
          $extractDir = "dist\zip-test"
          Expand-Archive -Path "dist\pgtail-windows-x86_64.zip" -DestinationPath $extractDir

          # Verify structure
          if (-not (Test-Path "$extractDir\pgtail-windows-x86_64\pgtail.exe")) {
            Write-Error "pgtail.exe not found in extracted ZIP"
            Get-ChildItem -Recurse $extractDir
            exit 1
          }

          # Run extracted executable
          & "$extractDir\pgtail-windows-x86_64\pgtail.exe" --version

          # Cleanup
          Remove-Item -Recurse -Force $extractDir

      - name: Extract version from tag
        id: version
        shell: pwsh
        run: |
          # Full version for display (e.g., 0.2.0-rc1)
          $fullVersion = "${{ github.ref_name }}" -replace '^v', ''
          echo "full_version=$fullVersion" >> $env:GITHUB_OUTPUT

          # MSI version must be numeric only (X.Y.Z), strip prerelease suffix
          $msiVersion = $fullVersion -replace '-.*$', ''
          echo "msi_version=$msiVersion" >> $env:GITHUB_OUTPUT
          Write-Host "Full version: $fullVersion, MSI version: $msiVersion"

      - name: Install WiX Toolset
        run: dotnet tool install --global wix --version 5.0.2

      - name: Build MSI with WiX
        shell: pwsh
        run: |
          # WiX v5 uses Files element for harvesting (no heat required)
          # Use MSI-compatible version (numeric only, no prerelease suffix)
          # SourceDir must be relative to the .wxs file location (wix\), so use ..\dist\...
          wix build wix\pgtail.wxs `
            -d SourceDir=..\dist\pgtail-windows-x86_64 `
            -d Version=${{ steps.version.outputs.msi_version }} `
            -arch x64 `
            -out dist\pgtail-windows-x86_64.msi

      - name: Extract ProductCode from MSI
        id: msi_info
        shell: pwsh
        run: |
          # Extract ProductCode by reading MSI binary directly
          # Based on: https://xkln.net/blog/how-to-get-the-uninstall-code-product-code-from-an-msi-file-with-powershell/
          $msiPath = "dist\pgtail-windows-x86_64.msi"
          $pattern = 'ProductCode(\{[0-9a-fA-F-]{36}\})'
          $stream = [System.IO.File]::OpenRead($msiPath)
          $reader = [System.IO.StreamReader]::New($stream, [System.Text.Encoding]::ASCII)
          $productCode = $null
          while ($null -ne ($line = $reader.ReadLine())) {
            if ($line -match $pattern) {
              $productCode = $Matches[1]
              break
            }
          }
          $reader.Close()
          $stream.Close()

          if (-not $productCode) {
            Write-Error "Failed to extract ProductCode from MSI"
            exit 1
          }

          echo "product_code=$productCode" >> $env:GITHUB_OUTPUT
          Write-Host "ProductCode: $productCode"

      - name: Verify MSI installs correctly
        shell: pwsh
        run: |
          # Silent install to default location (Program Files\pgtail)
          # Use /l*v for verbose logging to diagnose issues
          $logFile = "dist\msi-install.log"
          $proc = Start-Process msiexec.exe -ArgumentList "/i", "dist\pgtail-windows-x86_64.msi", "/qn", "/l*v", $logFile -Wait -NoNewWindow -PassThru

          if ($proc.ExitCode -ne 0) {
            Write-Error "MSI installation failed with exit code: $($proc.ExitCode)"
            if (Test-Path $logFile) {
              Get-Content $logFile | Select-Object -Last 50
            }
            exit 1
          }

          # Verify executable exists and runs from default install path
          $exePath = "${env:ProgramFiles}\pgtail\pgtail.exe"
          if (-not (Test-Path $exePath)) {
            Write-Error "pgtail.exe not found at $exePath"
            Write-Host "Contents of Program Files:"
            Get-ChildItem "${env:ProgramFiles}" | Where-Object { $_.Name -like "*pgtail*" }
            Write-Host "MSI install log (last 50 lines):"
            if (Test-Path $logFile) {
              Get-Content $logFile | Select-Object -Last 50
            }
            exit 1
          }
          & $exePath --version

          # Test running with no arguments (simulates winget validation)
          Write-Host "`n=== Testing no-args execution (winget validation simulation) ==="

          # Test 1: Start-Process with -NoNewWindow (inherits parent console)
          Write-Host "Test 1: Start-Process -NoNewWindow"
          $proc = Start-Process -FilePath $exePath -NoNewWindow -Wait -PassThru
          Write-Host "Exit code: $($proc.ExitCode)"

          # Test 2: Direct invocation with & operator
          Write-Host "`nTest 2: Direct invocation with &"
          & $exePath
          Write-Host "Exit code (LASTEXITCODE): $LASTEXITCODE"

          # Test 3: Start-Process WITHOUT -NoNewWindow (new window/console)
          # This is the winget validation scenario - process gets its own console
          Write-Host "`nTest 3: Start-Process without -NoNewWindow (10s timeout)"
          $proc2 = Start-Process -FilePath $exePath -PassThru
          $completed = $proc2.WaitForExit(10000)  # 10 second timeout
          if (-not $completed) {
            Write-Host "ERROR: Test 3 timed out after 10s - killing process"
            $proc2.Kill()
            $proc2.WaitForExit()
            $proc2ExitCode = -1
          } else {
            $proc2ExitCode = $proc2.ExitCode
          }
          Write-Host "Exit code: $proc2ExitCode"

          # Test 4: cmd.exe /c invocation
          Write-Host "`nTest 4: cmd.exe /c invocation"
          cmd.exe /c $exePath
          Write-Host "Exit code (LASTEXITCODE): $LASTEXITCODE"

          # All tests must pass
          if ($proc.ExitCode -ne 0 -or $proc2ExitCode -ne 0 -or $LASTEXITCODE -ne 0) {
            Write-Error "One or more execution methods returned non-zero exit code"
            Write-Host "This will cause winget validation to fail"
            exit 1
          }

          # Silent uninstall
          Start-Process msiexec.exe -ArgumentList "/x", "dist\pgtail-windows-x86_64.msi", "/qn" -Wait -NoNewWindow

      - name: Upload ZIP artifact
        uses: actions/upload-artifact@v4
        with:
          name: pgtail-windows-x86_64
          path: dist/pgtail-windows-x86_64.zip
          retention-days: 1

      - name: Upload MSI artifact
        uses: actions/upload-artifact@v4
        with:
          name: pgtail-windows-x86_64-msi
          path: dist/pgtail-windows-x86_64.msi
          retention-days: 1

  # Build binary for Windows ARM64 (native ARM64 runner)
  build-windows-arm64:
    runs-on: windows-11-arm
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Install dependencies
        run: uv sync --extra dev

      - name: Build binary with Nuitka
        run: |
          uv run nuitka `
            --mode=standalone `
            --output-dir=dist `
            --output-filename=pgtail `
            --windows-icon-from-ico=art/pgtail.ico `
            --include-package=pgtail_py `
            --include-package=psutil `
            --include-package-data=certifi `
            --include-module=pgtail_py.detector_unix `
            --include-module=pgtail_py.detector_windows `
            --include-module=pgtail_py.notifier_unix `
            --include-module=pgtail_py.notifier_windows `
            --nofollow-import-to=psutil.tests `
            --python-flag=no_asserts `
            --python-flag=-m `
            --assume-yes-for-downloads `
            pgtail_py

      - name: Rename output directory
        shell: pwsh
        run: |
          # Nuitka outputs to pgtail.dist/, pgtail_py.dist/, or __main__.dist/
          if (Test-Path "dist\pgtail.dist") {
            Move-Item "dist\pgtail.dist" "dist\pgtail-windows-arm64"
          } elseif (Test-Path "dist\pgtail_py.dist") {
            Move-Item "dist\pgtail_py.dist" "dist\pgtail-windows-arm64"
          } elseif (Test-Path "dist\__main__.dist") {
            Move-Item "dist\__main__.dist" "dist\pgtail-windows-arm64"
          } else {
            Write-Error "Nuitka output directory not found"
            Get-ChildItem dist\
            exit 1
          }

      - name: Verify binary runs
        run: |
          .\dist\pgtail-windows-arm64\pgtail.exe --version

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: pgtail-windows-arm64
          path: dist/pgtail-windows-arm64
          retention-days: 1

  # Build MSIX bundle for Microsoft Store submission
  build-msix:
    needs: [build-windows, build-windows-arm64]
    runs-on: windows-latest
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v4

      - name: Download x64 build
        uses: actions/download-artifact@v4
        with:
          name: pgtail-windows-x86_64
          path: artifacts/x64

      - name: Download ARM64 build
        uses: actions/download-artifact@v4
        with:
          name: pgtail-windows-arm64
          path: artifacts/arm64

      - name: Extract x64 ZIP
        shell: pwsh
        run: |
          Expand-Archive -Path artifacts/x64/pgtail-windows-x86_64.zip -DestinationPath artifacts/x64/extracted

      - name: Convert version to MSIX format
        id: version
        shell: pwsh
        run: |
          # Strip 'v' prefix and any prerelease suffix, append .0 for MSIX
          $fullVersion = "${{ github.ref_name }}" -replace '^v', ''
          $msixVersion = ($fullVersion -replace '-.*$', '') + ".0"
          echo "msix_version=$msixVersion" >> $env:GITHUB_OUTPUT
          echo "full_version=$fullVersion" >> $env:GITHUB_OUTPUT
          Write-Host "Full version: $fullVersion, MSIX version: $msixVersion"

      - name: Validate version format
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.msix_version }}"
          if ($version -notmatch '^\d+\.\d+\.\d+\.0$') {
            Write-Error "Invalid MSIX version format: $version (expected X.Y.Z.0)"
            exit 1
          }

      - name: Substitute Package Identity in manifest
        shell: pwsh
        run: |
          $manifest = Get-Content msix/AppxManifest.xml -Raw
          $manifest = $manifest -replace 'YOUR_PACKAGE_IDENTITY_NAME', '${{ secrets.STORE_PACKAGE_NAME }}'
          $manifest = $manifest -replace 'YOUR_PUBLISHER_CN', '${{ secrets.STORE_PUBLISHER_CN }}'
          Set-Content -Path msix/AppxManifest.xml -Value $manifest
          Write-Host "Updated AppxManifest.xml with Package Identity"

      - name: Validate Package Identity substitution
        shell: pwsh
        run: |
          $manifest = Get-Content msix/AppxManifest.xml -Raw
          if ($manifest -match 'YOUR_PACKAGE_IDENTITY_NAME' -or $manifest -match 'YOUR_PUBLISHER_CN') {
            Write-Error "Package Identity placeholders not substituted. Check STORE_PACKAGE_NAME and STORE_PUBLISHER_CN secrets."
            exit 1
          }
          Write-Host "Package Identity validated"

      - name: Create x64 MSIX staging directory
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.msix_version }}"

          # Create staging directory
          New-Item -ItemType Directory -Path msix-stage-x64 -Force

          # Copy manifest and substitute version/architecture
          $manifest = Get-Content msix/AppxManifest.xml -Raw
          $manifest = $manifest -replace 'Version="0\.0\.0\.0"', "Version=`"$version`""
          $manifest = $manifest -replace 'ProcessorArchitecture="PROCESSOR_ARCHITECTURE"', 'ProcessorArchitecture="x64"'
          Set-Content -Path msix-stage-x64/AppxManifest.xml -Value $manifest

          # Copy assets
          Copy-Item -Path msix/Assets -Destination msix-stage-x64/Assets -Recurse

          # Copy Nuitka output to pgtail subdirectory (matches Executable path in manifest)
          Copy-Item -Path artifacts/x64/extracted/pgtail-windows-x86_64 -Destination msix-stage-x64/pgtail -Recurse

          # Verify structure
          Write-Host "x64 staging directory structure:"
          Get-ChildItem -Recurse msix-stage-x64 | Select-Object FullName

      - name: Create ARM64 MSIX staging directory
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.msix_version }}"

          # Create staging directory
          New-Item -ItemType Directory -Path msix-stage-arm64 -Force

          # Copy manifest and substitute version/architecture
          $manifest = Get-Content msix/AppxManifest.xml -Raw
          $manifest = $manifest -replace 'Version="0\.0\.0\.0"', "Version=`"$version`""
          $manifest = $manifest -replace 'ProcessorArchitecture="PROCESSOR_ARCHITECTURE"', 'ProcessorArchitecture="arm64"'
          Set-Content -Path msix-stage-arm64/AppxManifest.xml -Value $manifest

          # Copy assets
          Copy-Item -Path msix/Assets -Destination msix-stage-arm64/Assets -Recurse

          # Copy Nuitka output to pgtail subdirectory (matches Executable path in manifest)
          Copy-Item -Path artifacts/arm64 -Destination msix-stage-arm64/pgtail -Recurse

          # Verify structure
          Write-Host "ARM64 staging directory structure:"
          Get-ChildItem -Recurse msix-stage-arm64 | Select-Object FullName

      - name: Build x64 MSIX package
        shell: pwsh
        run: |
          # MakeAppx.exe is in Windows SDK
          $sdkPath = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\makeappx.exe" |
                     Sort-Object { [version]($_.Directory.Parent.Name) } -Descending |
                     Select-Object -First 1
          Write-Host "Using MakeAppx from: $($sdkPath.FullName)"

          & $sdkPath.FullName pack /d msix-stage-x64 /p pgtail-x64.msix /nv

          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to create x64 MSIX package"
            exit 1
          }

      - name: Build ARM64 MSIX package
        shell: pwsh
        run: |
          $sdkPath = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\makeappx.exe" |
                     Sort-Object { [version]($_.Directory.Parent.Name) } -Descending |
                     Select-Object -First 1

          & $sdkPath.FullName pack /d msix-stage-arm64 /p pgtail-arm64.msix /nv

          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to create ARM64 MSIX package"
            exit 1
          }

      - name: Create MSIX bundle
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.msix_version }}"

          # Create directory containing both MSIX packages
          New-Item -ItemType Directory -Path msix-packages -Force
          Move-Item pgtail-x64.msix msix-packages/
          Move-Item pgtail-arm64.msix msix-packages/

          $sdkPath = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\makeappx.exe" |
                     Sort-Object { [version]($_.Directory.Parent.Name) } -Descending |
                     Select-Object -First 1

          & $sdkPath.FullName bundle /d msix-packages /p pgtail.msixbundle /bv $version

          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to create MSIX bundle"
            exit 1
          }

          Write-Host "Created pgtail.msixbundle"
          Get-Item pgtail.msixbundle | Select-Object Name, Length

      - name: Check MSIX bundle size
        shell: pwsh
        run: |
          $bundle = Get-Item pgtail.msixbundle
          $sizeMB = [math]::Round($bundle.Length / 1MB, 2)
          Write-Host "MSIX bundle size: $sizeMB MB"

          if ($bundle.Length -gt 35MB) {
            Write-Warning "MSIX bundle exceeds 35MB: $sizeMB MB"
          }

      - name: Upload MSIX bundle artifact
        uses: actions/upload-artifact@v4
        with:
          name: pgtail-msixbundle
          path: pgtail.msixbundle
          retention-days: 1

  # Create release with all binaries
  release:
    needs: [build-unix, build-windows, build-msix]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      sha256_macos_arm64: ${{ steps.checksums.outputs.sha256_macos_arm64 }}
      sha256_macos_x86_64: ${{ steps.checksums.outputs.sha256_macos_x86_64 }}
      sha256_linux_x86_64: ${{ steps.checksums.outputs.sha256_linux_x86_64 }}
      sha256_linux_arm64: ${{ steps.checksums.outputs.sha256_linux_arm64 }}
      sha256_windows_x86_64: ${{ steps.checksums.outputs.sha256_windows_x86_64 }}
      sha256_windows_msi: ${{ steps.checksums.outputs.sha256_windows_msi }}
      sha256_msixbundle: ${{ steps.checksums.outputs.sha256_msixbundle }}

    steps:
      - name: Record workflow start time
        id: timing
        run: echo "start_time=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release files
        run: |
          mkdir -p release
          # Move archives to release directory
          mv artifacts/pgtail-macos-arm64/pgtail-macos-arm64.tar.gz release/
          mv artifacts/pgtail-macos-x86_64/pgtail-macos-x86_64.tar.gz release/
          mv artifacts/pgtail-linux-x86_64/pgtail-linux-x86_64.tar.gz release/
          mv artifacts/pgtail-linux-arm64/pgtail-linux-arm64.tar.gz release/
          mv artifacts/pgtail-windows-x86_64/pgtail-windows-x86_64.zip release/
          mv artifacts/pgtail-windows-x86_64-msi/pgtail-windows-x86_64.msi release/
          mv artifacts/pgtail-msixbundle/pgtail.msixbundle release/

      - name: Check archive sizes
        run: |
          echo "Checking archive sizes (max 50MB = 52428800 bytes)..."
          for archive in release/pgtail-*; do
            size=$(stat -c%s "$archive" 2>/dev/null || stat -f%z "$archive")
            echo "$archive: $size bytes"
            if [ "$size" -gt 52428800 ]; then
              echo "::error::Archive $archive exceeds 50MB limit: $size bytes"
              exit 1
            fi
          done
          echo "All archives within size limit."

      - name: Calculate SHA256 checksums
        id: checksums
        run: |
          cd release
          # Calculate and save checksums
          sha256sum pgtail-macos-arm64.tar.gz > pgtail-macos-arm64.tar.gz.sha256
          sha256sum pgtail-macos-x86_64.tar.gz > pgtail-macos-x86_64.tar.gz.sha256
          sha256sum pgtail-linux-x86_64.tar.gz > pgtail-linux-x86_64.tar.gz.sha256
          sha256sum pgtail-linux-arm64.tar.gz > pgtail-linux-arm64.tar.gz.sha256
          sha256sum pgtail-windows-x86_64.zip > pgtail-windows-x86_64.zip.sha256
          sha256sum pgtail-windows-x86_64.msi > pgtail-windows-x86_64.msi.sha256
          sha256sum pgtail.msixbundle > pgtail.msixbundle.sha256

          # Export checksums as outputs for downstream jobs
          echo "sha256_macos_arm64=$(cut -d' ' -f1 pgtail-macos-arm64.tar.gz.sha256)" >> $GITHUB_OUTPUT
          echo "sha256_macos_x86_64=$(cut -d' ' -f1 pgtail-macos-x86_64.tar.gz.sha256)" >> $GITHUB_OUTPUT
          echo "sha256_linux_x86_64=$(cut -d' ' -f1 pgtail-linux-x86_64.tar.gz.sha256)" >> $GITHUB_OUTPUT
          echo "sha256_linux_arm64=$(cut -d' ' -f1 pgtail-linux-arm64.tar.gz.sha256)" >> $GITHUB_OUTPUT
          echo "sha256_windows_x86_64=$(cut -d' ' -f1 pgtail-windows-x86_64.zip.sha256)" >> $GITHUB_OUTPUT
          echo "sha256_windows_msi=$(cut -d' ' -f1 pgtail-windows-x86_64.msi.sha256)" >> $GITHUB_OUTPUT
          echo "sha256_msixbundle=$(cut -d' ' -f1 pgtail.msixbundle.sha256)" >> $GITHUB_OUTPUT

          # Display checksums
          echo "SHA256 Checksums:"
          cat *.sha256

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            release/pgtail-macos-arm64.tar.gz
            release/pgtail-macos-arm64.tar.gz.sha256
            release/pgtail-macos-x86_64.tar.gz
            release/pgtail-macos-x86_64.tar.gz.sha256
            release/pgtail-linux-x86_64.tar.gz
            release/pgtail-linux-x86_64.tar.gz.sha256
            release/pgtail-linux-arm64.tar.gz
            release/pgtail-linux-arm64.tar.gz.sha256
            release/pgtail-windows-x86_64.zip
            release/pgtail-windows-x86_64.zip.sha256
            release/pgtail-windows-x86_64.msi
            release/pgtail-windows-x86_64.msi.sha256
            release/pgtail.msixbundle
            release/pgtail.msixbundle.sha256
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check workflow timing
        run: |
          end_time=$(date +%s)
          start_time=${{ steps.timing.outputs.start_time }}
          duration=$((end_time - start_time))
          max_duration=$((15 * 60))  # 15 minutes in seconds

          echo "Release job duration: ${duration}s"
          if [ "$duration" -gt "$max_duration" ]; then
            echo "::warning::Release job exceeded 15 minute target: ${duration}s"
          else
            echo "Release job completed within target time."
          fi

  # Update Homebrew formula with new version and checksums
  update-homebrew:
    needs: release
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Extract version from tag
        id: version
        run: |
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Updating Homebrew formula to version $VERSION"

      - name: Clone homebrew-tap repository
        run: |
          git clone https://x-access-token:${{ secrets.HOMEBREW_TAP_TOKEN }}@github.com/willibrandon/homebrew-tap.git
          cd homebrew-tap
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update formula with new version and checksums
        run: |
          cd homebrew-tap
          VERSION="${{ steps.version.outputs.version }}"

          # Update version
          sed -i "s/version \".*\"/version \"$VERSION\"/" Formula/pgtail.rb

          # Update SHA256 checksums using Python for reliable replacement
          python3 << 'EOF'
          import re

          with open('Formula/pgtail.rb', 'r') as f:
              content = f.read()

          # Define SHA256 values from release artifacts
          shas = {
              'macos-arm64': '${{ needs.release.outputs.sha256_macos_arm64 }}',
              'macos-x86_64': '${{ needs.release.outputs.sha256_macos_x86_64 }}',
              'linux-arm64': '${{ needs.release.outputs.sha256_linux_arm64 }}',
              'linux-x86_64': '${{ needs.release.outputs.sha256_linux_x86_64 }}',
          }

          # Replace SHA256 placeholders for each platform
          # Pattern matches: sha256 "PLACEHOLDER" or sha256 "abc123..."
          for platform, sha in shas.items():
              # Match the url line followed by sha256 line for each platform
              pattern = rf'(url "https://github\.com/willibrandon/pgtail/releases/download/v#\{{version\}}/pgtail-{platform}\.tar\.gz"\s+sha256 ")[^"]*(")'
              content = re.sub(pattern, rf'\g<1>{sha}\2', content)

          with open('Formula/pgtail.rb', 'w') as f:
              f.write(content)
          EOF

          echo "Updated Formula/pgtail.rb:"
          cat Formula/pgtail.rb

      - name: Commit and push changes
        run: |
          cd homebrew-tap
          VERSION="${{ steps.version.outputs.version }}"

          git add Formula/pgtail.rb
          git diff --staged --quiet || git commit -m "Update pgtail to $VERSION"
          git push origin main

  # Update winget manifest and submit PR
  update-winget:
    needs: release
    runs-on: windows-latest
    timeout-minutes: 30
    steps:
      - name: Extract version from tag
        id: version
        shell: pwsh
        run: |
          $version = "${{ github.ref_name }}" -replace '^v', ''
          echo "version=$version" >> $env:GITHUB_OUTPUT
          echo "Updating winget manifest to version $version"

      - name: Check if package exists in winget-pkgs
        id: check
        shell: pwsh
        run: |
          $response = Invoke-WebRequest -Uri "https://api.github.com/repos/microsoft/winget-pkgs/contents/manifests/w/willibrandon/pgtail" -Method Head -SkipHttpErrorCheck
          if ($response.StatusCode -eq 200) {
            echo "exists=true" >> $env:GITHUB_OUTPUT
          } else {
            echo "exists=false" >> $env:GITHUB_OUTPUT
            echo "Package not yet in winget-pkgs, skipping update"
          }

      - name: Install wingetcreate
        if: steps.check.outputs.exists == 'true'
        shell: pwsh
        run: |
          Invoke-WebRequest -Uri https://aka.ms/wingetcreate/latest -OutFile wingetcreate.exe

      - name: Generate winget manifest
        if: steps.check.outputs.exists == 'true'
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $version = "${{ steps.version.outputs.version }}"
          $url = "https://github.com/willibrandon/pgtail/releases/download/v$version/pgtail-windows-x86_64.msi"

          # Use --token to auto-fill ReleaseDate and ReleaseNotesUrl from GitHub release
          .\wingetcreate.exe update willibrandon.pgtail `
            --version $version `
            --urls $url `
            --token $env:GH_TOKEN `
            --out manifests

      - name: Submit winget PR via GitHub API
        if: steps.check.outputs.exists == 'true'
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.WINGET_PKGS_TOKEN }}
        run: |
          $version = "${{ steps.version.outputs.version }}"
          $branch = "pgtail-$version"
          $manifestDir = "manifests/w/willibrandon/pgtail/$version"

          # Sync fork with upstream first
          Write-Host "Syncing fork with upstream..."
          gh api repos/willibrandon/winget-pkgs/merge-upstream -X POST -f branch="master"

          # Get fork's master commit SHA (now synced with upstream)
          $forkRef = gh api repos/willibrandon/winget-pkgs/git/ref/heads/master --jq '.object.sha'
          Write-Host "Fork master SHA: $forkRef"

          # Get the tree SHA for that commit
          $baseTreeSha = gh api "repos/willibrandon/winget-pkgs/git/commits/$forkRef" --jq '.tree.sha'
          Write-Host "Base tree SHA: $baseTreeSha"

          # Create blobs for each manifest file and build tree entries
          $treeEntries = [System.Collections.ArrayList]@()
          Get-ChildItem -Path "manifests" -Recurse -File | ForEach-Object {
            $content = [Convert]::ToBase64String([System.IO.File]::ReadAllBytes($_.FullName))
            $blobResponse = gh api repos/willibrandon/winget-pkgs/git/blobs -X POST -f content="$content" -f encoding="base64"
            $blobSha = $blobResponse | ConvertFrom-Json | Select-Object -ExpandProperty sha
            $path = "$manifestDir/$($_.Name)"
            Write-Host "Created blob for $path : $blobSha"
            [void]$treeEntries.Add(@{path=$path; mode="100644"; type="blob"; sha=$blobSha})
          }

          # Create new tree with manifest files added
          $treeData = @{base_tree=$baseTreeSha; tree=$treeEntries.ToArray()}
          $treeJson = $treeData | ConvertTo-Json -Depth 10
          Write-Host "Tree JSON: $treeJson"
          $treeJson | Out-File -FilePath tree.json -Encoding utf8NoBOM
          $newTree = gh api repos/willibrandon/winget-pkgs/git/trees -X POST --input tree.json
          $newTreeSha = $newTree | ConvertFrom-Json | Select-Object -ExpandProperty sha
          Write-Host "New tree SHA: $newTreeSha"

          # Create commit
          $commitJson = @{
            message="Update willibrandon.pgtail to $version"
            tree=$newTreeSha
            parents=@($forkRef)
          } | ConvertTo-Json -Compress
          $commitJson | Out-File -FilePath commit.json -Encoding utf8
          $newCommit = gh api repos/willibrandon/winget-pkgs/git/commits -X POST --input commit.json
          $newCommitSha = $newCommit | ConvertFrom-Json | Select-Object -ExpandProperty sha
          Write-Host "New commit SHA: $newCommitSha"

          # Create or update branch reference
          $refExists = gh api "repos/willibrandon/winget-pkgs/git/ref/heads/$branch" 2>$null
          if ($LASTEXITCODE -eq 0) {
            gh api "repos/willibrandon/winget-pkgs/git/refs/heads/$branch" -X PATCH -f sha="$newCommitSha" -F force=true
          } else {
            gh api repos/willibrandon/winget-pkgs/git/refs -X POST -f ref="refs/heads/$branch" -f sha="$newCommitSha"
          }
          Write-Host "Branch $branch updated to $newCommitSha"

          # Create PR
          gh pr create `
            --repo microsoft/winget-pkgs `
            --base master `
            --head willibrandon:$branch `
            --title "Update willibrandon.pgtail to $version" `
            --body "## Description`n`nUpdate pgtail to version $version`n`n## Release notes`n`nhttps://github.com/willibrandon/pgtail/releases/tag/v$version"

  # Submit MSIX bundle to Microsoft Store via Partner Center API
  update-store:
    needs: [build-msix, release]
    runs-on: windows-latest
    timeout-minutes: 30

    steps:
      - name: Download MSIX bundle
        uses: actions/download-artifact@v4
        with:
          name: pgtail-msixbundle
          path: artifacts

      - name: Extract version from tag
        id: version
        shell: pwsh
        run: |
          $version = "${{ github.ref_name }}" -replace '^v', ''
          echo "version=$version" >> $env:GITHUB_OUTPUT
          Write-Host "Submitting version $version to Microsoft Store"

      - name: Get OAuth access token
        id: auth
        shell: pwsh
        run: |
          $body = @{
            grant_type    = "client_credentials"
            client_id     = "${{ secrets.STORE_CLIENT_ID }}"
            client_secret = "${{ secrets.STORE_CLIENT_SECRET }}"
            resource      = "https://manage.devcenter.microsoft.com"
          }

          $response = Invoke-RestMethod -Method Post `
            -Uri "https://login.microsoftonline.com/${{ secrets.STORE_TENANT_ID }}/oauth2/token" `
            -Body $body

          # Mask token in logs
          Write-Host "::add-mask::$($response.access_token)"
          echo "token=$($response.access_token)" >> $env:GITHUB_OUTPUT
          Write-Host "OAuth token obtained successfully"

      - name: Get application and check for pending submission
        id: app_info
        shell: pwsh
        env:
          TOKEN: ${{ steps.auth.outputs.token }}
        run: |
          $headers = @{
            Authorization = "Bearer $env:TOKEN"
          }

          $app = Invoke-RestMethod -Method Get `
            -Uri "https://manage.devcenter.microsoft.com/v1.0/my/applications/${{ secrets.STORE_APP_ID }}" `
            -Headers $headers

          Write-Host "Application: $($app.primaryName)"
          Write-Host "Package Family: $($app.packageFamilyName)"

          if ($app.pendingApplicationSubmission) {
            $pendingId = $app.pendingApplicationSubmission.id
            Write-Host "Pending submission found: $pendingId"
            echo "pending_id=$pendingId" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "No pending submission"
            echo "pending_id=" >> $env:GITHUB_OUTPUT
          }

      - name: Delete pending submission if exists
        if: steps.app_info.outputs.pending_id != ''
        shell: pwsh
        env:
          TOKEN: ${{ steps.auth.outputs.token }}
        run: |
          $headers = @{
            Authorization = "Bearer $env:TOKEN"
          }

          $pendingId = "${{ steps.app_info.outputs.pending_id }}"
          Write-Host "Deleting pending submission: $pendingId"

          Invoke-RestMethod -Method Delete `
            -Uri "https://manage.devcenter.microsoft.com/v1.0/my/applications/${{ secrets.STORE_APP_ID }}/submissions/$pendingId" `
            -Headers $headers

          Write-Host "Pending submission deleted"

      - name: Create new submission
        id: create_submission
        shell: pwsh
        env:
          TOKEN: ${{ steps.auth.outputs.token }}
        run: |
          $headers = @{
            Authorization = "Bearer $env:TOKEN"
          }

          $submission = Invoke-RestMethod -Method Post `
            -Uri "https://manage.devcenter.microsoft.com/v1.0/my/applications/${{ secrets.STORE_APP_ID }}/submissions" `
            -Headers $headers

          Write-Host "Created submission: $($submission.id)"
          Write-Host "Status: $($submission.status)"
          Write-Host "Upload URL obtained"

          # Mask the SAS URL in logs
          Write-Host "::add-mask::$($submission.fileUploadUrl)"

          echo "submission_id=$($submission.id)" >> $env:GITHUB_OUTPUT
          echo "upload_url=$($submission.fileUploadUrl)" >> $env:GITHUB_OUTPUT

          # Save submission for update
          $submission | ConvertTo-Json -Depth 10 | Out-File -FilePath submission.json -Encoding utf8

      - name: Update submission with package metadata
        shell: pwsh
        env:
          TOKEN: ${{ steps.auth.outputs.token }}
        run: |
          $headers = @{
            Authorization  = "Bearer $env:TOKEN"
            "Content-Type" = "application/json"
          }

          # Read current submission
          $submission = Get-Content submission.json | ConvertFrom-Json

          # Update package info
          $submission.applicationPackages = @(
            @{
              fileName              = "pgtail.msixbundle"
              fileStatus            = "PendingUpload"
              minimumDirectXVersion = "None"
              minimumSystemRam      = "None"
            }
          )

          $body = $submission | ConvertTo-Json -Depth 10

          $updated = Invoke-RestMethod -Method Put `
            -Uri "https://manage.devcenter.microsoft.com/v1.0/my/applications/${{ secrets.STORE_APP_ID }}/submissions/${{ steps.create_submission.outputs.submission_id }}" `
            -Headers $headers `
            -Body $body

          Write-Host "Submission updated with package metadata"

      - name: Create submission ZIP
        shell: pwsh
        run: |
          # Partner Center requires the MSIX bundle inside a ZIP
          Compress-Archive -Path artifacts/pgtail.msixbundle -DestinationPath submission.zip
          Write-Host "Created submission.zip"
          Get-Item submission.zip | Select-Object Name, Length

      - name: Upload to Azure Blob Storage
        shell: pwsh
        env:
          UPLOAD_URL: ${{ steps.create_submission.outputs.upload_url }}
        run: |
          $maxRetries = 3
          $delays = @(30, 60, 120)

          for ($i = 0; $i -lt $maxRetries; $i++) {
            try {
              Write-Host "Upload attempt $($i + 1) of $maxRetries..."

              $headers = @{
                "x-ms-blob-type" = "BlockBlob"
              }

              Invoke-RestMethod -Method Put `
                -Uri $env:UPLOAD_URL `
                -Headers $headers `
                -InFile submission.zip `
                -ContentType "application/zip"

              Write-Host "Upload successful"
              break
            } catch {
              Write-Host "Upload failed: $_"
              if ($i -eq $maxRetries - 1) {
                throw "Upload failed after $maxRetries attempts"
              }
              Write-Host "Retrying in $($delays[$i]) seconds..."
              Start-Sleep -Seconds $delays[$i]
            }
          }

      - name: Commit submission
        id: commit
        shell: pwsh
        env:
          TOKEN: ${{ steps.auth.outputs.token }}
        run: |
          $headers = @{
            Authorization = "Bearer $env:TOKEN"
          }

          $result = Invoke-RestMethod -Method Post `
            -Uri "https://manage.devcenter.microsoft.com/v1.0/my/applications/${{ secrets.STORE_APP_ID }}/submissions/${{ steps.create_submission.outputs.submission_id }}/commit" `
            -Headers $headers

          Write-Host "Commit initiated: $($result.status)"

      - name: Poll submission status
        id: poll
        shell: pwsh
        env:
          TOKEN: ${{ steps.auth.outputs.token }}
        run: |
          $headers = @{
            Authorization = "Bearer $env:TOKEN"
          }

          $maxPolls = 30
          $pollInterval = 30  # seconds

          for ($i = 0; $i -lt $maxPolls; $i++) {
            $status = Invoke-RestMethod -Method Get `
              -Uri "https://manage.devcenter.microsoft.com/v1.0/my/applications/${{ secrets.STORE_APP_ID }}/submissions/${{ steps.create_submission.outputs.submission_id }}/status" `
              -Headers $headers

            Write-Host "Poll $($i + 1): Status = $($status.status)"

            if ($status.status -ne "CommitStarted") {
              echo "final_status=$($status.status)" >> $env:GITHUB_OUTPUT

              if ($status.statusDetails.errors.Count -gt 0) {
                Write-Host "Errors:"
                $status.statusDetails.errors | ForEach-Object { Write-Host "  - $($_.code): $($_.details)" }
              }

              if ($status.statusDetails.warnings.Count -gt 0) {
                Write-Host "Warnings:"
                $status.statusDetails.warnings | ForEach-Object { Write-Host "  - $($_.code): $($_.details)" }
              }

              break
            }

            Start-Sleep -Seconds $pollInterval
          }

          if ($status.status -eq "CommitStarted") {
            Write-Host "::warning::Polling timed out, submission still processing"
            echo "final_status=CommitStarted" >> $env:GITHUB_OUTPUT
          }

      - name: Validate final status
        shell: pwsh
        run: |
          $status = "${{ steps.poll.outputs.final_status }}"
          $validStatuses = @("PreProcessing", "Certification", "Release", "Publishing")

          if ($status -in $validStatuses) {
            Write-Host "Submission successful: $status"
          } elseif ($status -eq "CommitStarted") {
            Write-Host "::warning::Submission still processing, check Partner Center for status"
          } else {
            Write-Error "Submission failed with status: $status"
            exit 1
          }

      - name: Output workflow summary
        shell: pwsh
        run: |
          $summary = @"
          ## Microsoft Store Submission

          | Field | Value |
          |-------|-------|
          | Version | ${{ steps.version.outputs.version }} |
          | Submission ID | ${{ steps.create_submission.outputs.submission_id }} |
          | Final Status | ${{ steps.poll.outputs.final_status }} |

          View submission in [Partner Center](https://partner.microsoft.com/dashboard/apps/${{ secrets.STORE_APP_ID }}/submissions)
          "@

          echo $summary >> $env:GITHUB_STEP_SUMMARY

  # Notify on failure
  notify-failure:
    needs: [build-unix, build-windows, build-windows-arm64, build-msix, release, update-homebrew, update-winget, update-store]
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: Create failure issue
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const runUrl = `https://github.com/${owner}/${repo}/actions/runs/${context.runId}`;
            const tag = context.ref.replace('refs/tags/', '');

            await github.rest.issues.create({
              owner,
              repo,
              title: `Release ${tag} failed`,
              body: `The release workflow for ${tag} failed.\n\nSee the [workflow run](${runUrl}) for details.`,
              labels: ['bug', 'release']
            });
