name: Release

on:
  push:
    tags:
      - 'v*'

# Permissions required for creating releases, pushing to homebrew-tap, and creating issues
permissions:
  contents: write
  issues: write

jobs:
  # Build binaries for Unix-like systems (macOS and Linux)
  build-unix:
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-14
            platform: macos
            arch: arm64
          - os: macos-15-intel
            platform: macos
            arch: x86_64
          - os: ubuntu-latest
            platform: linux
            arch: x86_64
          - os: ubuntu-24.04-arm
            platform: linux
            arch: arm64

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Install dependencies
        run: uv sync --extra dev

      - name: Build binary with Nuitka
        run: |
          uv run nuitka \
            --mode=standalone \
            --output-dir=dist \
            --output-filename=pgtail \
            --include-package=pgtail_py \
            --include-package=psutil \
            --include-package-data=certifi \
            --include-module=pgtail_py.detector_unix \
            --include-module=pgtail_py.detector_windows \
            --include-module=pgtail_py.notifier_unix \
            --include-module=pgtail_py.notifier_windows \
            --nofollow-import-to=psutil.tests \
            --python-flag=no_asserts \
            --python-flag=-m \
            --assume-yes-for-downloads \
            pgtail_py

      - name: Rename output directory
        run: |
          # Nuitka outputs to pgtail.dist/, pgtail_py.dist/, or __main__.dist/
          if [ -d "dist/pgtail.dist" ]; then
            mv dist/pgtail.dist dist/pgtail-${{ matrix.platform }}-${{ matrix.arch }}
          elif [ -d "dist/pgtail_py.dist" ]; then
            mv dist/pgtail_py.dist dist/pgtail-${{ matrix.platform }}-${{ matrix.arch }}
          elif [ -d "dist/__main__.dist" ]; then
            mv dist/__main__.dist dist/pgtail-${{ matrix.platform }}-${{ matrix.arch }}
          else
            echo "ERROR: Nuitka output directory not found"
            ls -la dist/
            exit 1
          fi

      - name: Verify binary runs
        run: |
          ./dist/pgtail-${{ matrix.platform }}-${{ matrix.arch }}/pgtail --version

      - name: Create tar.gz archive
        run: |
          cd dist
          tar -czvf pgtail-${{ matrix.platform }}-${{ matrix.arch }}.tar.gz pgtail-${{ matrix.platform }}-${{ matrix.arch }}

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: pgtail-${{ matrix.platform }}-${{ matrix.arch }}
          path: dist/pgtail-${{ matrix.platform }}-${{ matrix.arch }}.tar.gz
          retention-days: 1

  # Build binary for Windows (separate job due to different shell syntax)
  build-windows:
    runs-on: windows-latest
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Install dependencies
        run: uv sync --extra dev

      - name: Build binary with Nuitka
        run: |
          uv run nuitka `
            --mode=standalone `
            --output-dir=dist `
            --output-filename=pgtail `
            --windows-icon-from-ico=art/pgtail.ico `
            --include-package=pgtail_py `
            --include-package=psutil `
            --include-package-data=certifi `
            --include-module=pgtail_py.detector_unix `
            --include-module=pgtail_py.detector_windows `
            --include-module=pgtail_py.notifier_unix `
            --include-module=pgtail_py.notifier_windows `
            --nofollow-import-to=psutil.tests `
            --python-flag=no_asserts `
            --python-flag=-m `
            --assume-yes-for-downloads `
            pgtail_py

      - name: Rename output directory
        shell: pwsh
        run: |
          # Nuitka outputs to pgtail.dist/, pgtail_py.dist/, or __main__.dist/
          if (Test-Path "dist\pgtail.dist") {
            Move-Item "dist\pgtail.dist" "dist\pgtail-windows-x86_64"
          } elseif (Test-Path "dist\pgtail_py.dist") {
            Move-Item "dist\pgtail_py.dist" "dist\pgtail-windows-x86_64"
          } elseif (Test-Path "dist\__main__.dist") {
            Move-Item "dist\__main__.dist" "dist\pgtail-windows-x86_64"
          } else {
            Write-Error "Nuitka output directory not found"
            Get-ChildItem dist\
            exit 1
          }

      - name: Verify binary runs
        run: |
          .\dist\pgtail-windows-x86_64\pgtail.exe --version

      - name: Create ZIP archive
        shell: pwsh
        run: |
          Compress-Archive -Path "dist\pgtail-windows-x86_64" -DestinationPath "dist\pgtail-windows-x86_64.zip"

      - name: Verify ZIP extraction and executable
        shell: pwsh
        run: |
          # Extract to temp directory
          $extractDir = "dist\zip-test"
          Expand-Archive -Path "dist\pgtail-windows-x86_64.zip" -DestinationPath $extractDir

          # Verify structure
          if (-not (Test-Path "$extractDir\pgtail-windows-x86_64\pgtail.exe")) {
            Write-Error "pgtail.exe not found in extracted ZIP"
            Get-ChildItem -Recurse $extractDir
            exit 1
          }

          # Run extracted executable
          & "$extractDir\pgtail-windows-x86_64\pgtail.exe" --version

          # Cleanup
          Remove-Item -Recurse -Force $extractDir

      - name: Extract version from tag
        id: version
        shell: pwsh
        run: |
          # Full version for display (e.g., 0.2.0-rc1)
          $fullVersion = "${{ github.ref_name }}" -replace '^v', ''
          echo "full_version=$fullVersion" >> $env:GITHUB_OUTPUT

          # MSI version must be numeric only (X.Y.Z), strip prerelease suffix
          $msiVersion = $fullVersion -replace '-.*$', ''
          echo "msi_version=$msiVersion" >> $env:GITHUB_OUTPUT
          Write-Host "Full version: $fullVersion, MSI version: $msiVersion"

      - name: Install WiX Toolset
        run: dotnet tool install --global wix --version 5.0.2

      - name: Build MSI with WiX
        shell: pwsh
        run: |
          # WiX v5 uses Files element for harvesting (no heat required)
          # Use MSI-compatible version (numeric only, no prerelease suffix)
          # SourceDir must be relative to the .wxs file location (wix\), so use ..\dist\...
          wix build wix\pgtail.wxs `
            -d SourceDir=..\dist\pgtail-windows-x86_64 `
            -d Version=${{ steps.version.outputs.msi_version }} `
            -arch x64 `
            -out dist\pgtail-windows-x86_64.msi

      - name: Extract ProductCode from MSI
        id: msi_info
        shell: pwsh
        run: |
          # Extract ProductCode by reading MSI binary directly
          # Based on: https://xkln.net/blog/how-to-get-the-uninstall-code-product-code-from-an-msi-file-with-powershell/
          $msiPath = "dist\pgtail-windows-x86_64.msi"
          $pattern = 'ProductCode(\{[0-9a-fA-F-]{36}\})'
          $stream = [System.IO.File]::OpenRead($msiPath)
          $reader = [System.IO.StreamReader]::New($stream, [System.Text.Encoding]::ASCII)
          $productCode = $null
          while ($null -ne ($line = $reader.ReadLine())) {
            if ($line -match $pattern) {
              $productCode = $Matches[1]
              break
            }
          }
          $reader.Close()
          $stream.Close()

          if (-not $productCode) {
            Write-Error "Failed to extract ProductCode from MSI"
            exit 1
          }

          echo "product_code=$productCode" >> $env:GITHUB_OUTPUT
          Write-Host "ProductCode: $productCode"

      - name: Verify MSI installs correctly
        shell: pwsh
        run: |
          # Silent install to default location (Program Files\pgtail)
          # Use /l*v for verbose logging to diagnose issues
          $logFile = "dist\msi-install.log"
          $proc = Start-Process msiexec.exe -ArgumentList "/i", "dist\pgtail-windows-x86_64.msi", "/qn", "/l*v", $logFile -Wait -NoNewWindow -PassThru

          if ($proc.ExitCode -ne 0) {
            Write-Error "MSI installation failed with exit code: $($proc.ExitCode)"
            if (Test-Path $logFile) {
              Get-Content $logFile | Select-Object -Last 50
            }
            exit 1
          }

          # Verify executable exists and runs from default install path
          $exePath = "${env:ProgramFiles}\pgtail\pgtail.exe"
          if (-not (Test-Path $exePath)) {
            Write-Error "pgtail.exe not found at $exePath"
            Write-Host "Contents of Program Files:"
            Get-ChildItem "${env:ProgramFiles}" | Where-Object { $_.Name -like "*pgtail*" }
            Write-Host "MSI install log (last 50 lines):"
            if (Test-Path $logFile) {
              Get-Content $logFile | Select-Object -Last 50
            }
            exit 1
          }
          & $exePath --version

          # Test running with no arguments (simulates winget validation)
          Write-Host "`n=== Testing no-args execution (winget validation simulation) ==="

          # Test 1: Start-Process with -NoNewWindow (inherits parent console)
          Write-Host "Test 1: Start-Process -NoNewWindow"
          $proc = Start-Process -FilePath $exePath -NoNewWindow -Wait -PassThru
          Write-Host "Exit code: $($proc.ExitCode)"

          # Test 2: Direct invocation with & operator
          Write-Host "`nTest 2: Direct invocation with &"
          & $exePath
          Write-Host "Exit code (LASTEXITCODE): $LASTEXITCODE"

          # Test 3: Start-Process WITHOUT -NoNewWindow (new window/console)
          # This is the winget validation scenario - process gets its own console
          Write-Host "`nTest 3: Start-Process without -NoNewWindow (10s timeout)"
          $proc2 = Start-Process -FilePath $exePath -PassThru
          $completed = $proc2.WaitForExit(10000)  # 10 second timeout
          if (-not $completed) {
            Write-Host "ERROR: Test 3 timed out after 10s - killing process"
            $proc2.Kill()
            $proc2.WaitForExit()
            $proc2ExitCode = -1
          } else {
            $proc2ExitCode = $proc2.ExitCode
          }
          Write-Host "Exit code: $proc2ExitCode"

          # Test 4: cmd.exe /c invocation
          Write-Host "`nTest 4: cmd.exe /c invocation"
          cmd.exe /c $exePath
          Write-Host "Exit code (LASTEXITCODE): $LASTEXITCODE"

          # All tests must pass
          if ($proc.ExitCode -ne 0 -or $proc2ExitCode -ne 0 -or $LASTEXITCODE -ne 0) {
            Write-Error "One or more execution methods returned non-zero exit code"
            Write-Host "This will cause winget validation to fail"
            exit 1
          }

          # Silent uninstall
          Start-Process msiexec.exe -ArgumentList "/x", "dist\pgtail-windows-x86_64.msi", "/qn" -Wait -NoNewWindow

      - name: Upload ZIP artifact
        uses: actions/upload-artifact@v4
        with:
          name: pgtail-windows-x86_64
          path: dist/pgtail-windows-x86_64.zip
          retention-days: 1

      - name: Upload MSI artifact
        uses: actions/upload-artifact@v4
        with:
          name: pgtail-windows-x86_64-msi
          path: dist/pgtail-windows-x86_64.msi
          retention-days: 1

  # Create release with all binaries
  release:
    needs: [build-unix, build-windows]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      sha256_macos_arm64: ${{ steps.checksums.outputs.sha256_macos_arm64 }}
      sha256_macos_x86_64: ${{ steps.checksums.outputs.sha256_macos_x86_64 }}
      sha256_linux_x86_64: ${{ steps.checksums.outputs.sha256_linux_x86_64 }}
      sha256_linux_arm64: ${{ steps.checksums.outputs.sha256_linux_arm64 }}
      sha256_windows_x86_64: ${{ steps.checksums.outputs.sha256_windows_x86_64 }}
      sha256_windows_msi: ${{ steps.checksums.outputs.sha256_windows_msi }}

    steps:
      - name: Record workflow start time
        id: timing
        run: echo "start_time=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release files
        run: |
          mkdir -p release
          # Move archives to release directory
          mv artifacts/pgtail-macos-arm64/pgtail-macos-arm64.tar.gz release/
          mv artifacts/pgtail-macos-x86_64/pgtail-macos-x86_64.tar.gz release/
          mv artifacts/pgtail-linux-x86_64/pgtail-linux-x86_64.tar.gz release/
          mv artifacts/pgtail-linux-arm64/pgtail-linux-arm64.tar.gz release/
          mv artifacts/pgtail-windows-x86_64/pgtail-windows-x86_64.zip release/
          mv artifacts/pgtail-windows-x86_64-msi/pgtail-windows-x86_64.msi release/

      - name: Check archive sizes
        run: |
          echo "Checking archive sizes (max 50MB = 52428800 bytes)..."
          for archive in release/pgtail-*; do
            size=$(stat -c%s "$archive" 2>/dev/null || stat -f%z "$archive")
            echo "$archive: $size bytes"
            if [ "$size" -gt 52428800 ]; then
              echo "::error::Archive $archive exceeds 50MB limit: $size bytes"
              exit 1
            fi
          done
          echo "All archives within size limit."

      - name: Calculate SHA256 checksums
        id: checksums
        run: |
          cd release
          # Calculate and save checksums
          sha256sum pgtail-macos-arm64.tar.gz > pgtail-macos-arm64.tar.gz.sha256
          sha256sum pgtail-macos-x86_64.tar.gz > pgtail-macos-x86_64.tar.gz.sha256
          sha256sum pgtail-linux-x86_64.tar.gz > pgtail-linux-x86_64.tar.gz.sha256
          sha256sum pgtail-linux-arm64.tar.gz > pgtail-linux-arm64.tar.gz.sha256
          sha256sum pgtail-windows-x86_64.zip > pgtail-windows-x86_64.zip.sha256
          sha256sum pgtail-windows-x86_64.msi > pgtail-windows-x86_64.msi.sha256

          # Export checksums as outputs for downstream jobs
          echo "sha256_macos_arm64=$(cut -d' ' -f1 pgtail-macos-arm64.tar.gz.sha256)" >> $GITHUB_OUTPUT
          echo "sha256_macos_x86_64=$(cut -d' ' -f1 pgtail-macos-x86_64.tar.gz.sha256)" >> $GITHUB_OUTPUT
          echo "sha256_linux_x86_64=$(cut -d' ' -f1 pgtail-linux-x86_64.tar.gz.sha256)" >> $GITHUB_OUTPUT
          echo "sha256_linux_arm64=$(cut -d' ' -f1 pgtail-linux-arm64.tar.gz.sha256)" >> $GITHUB_OUTPUT
          echo "sha256_windows_x86_64=$(cut -d' ' -f1 pgtail-windows-x86_64.zip.sha256)" >> $GITHUB_OUTPUT
          echo "sha256_windows_msi=$(cut -d' ' -f1 pgtail-windows-x86_64.msi.sha256)" >> $GITHUB_OUTPUT

          # Display checksums
          echo "SHA256 Checksums:"
          cat *.sha256

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            release/pgtail-macos-arm64.tar.gz
            release/pgtail-macos-arm64.tar.gz.sha256
            release/pgtail-macos-x86_64.tar.gz
            release/pgtail-macos-x86_64.tar.gz.sha256
            release/pgtail-linux-x86_64.tar.gz
            release/pgtail-linux-x86_64.tar.gz.sha256
            release/pgtail-linux-arm64.tar.gz
            release/pgtail-linux-arm64.tar.gz.sha256
            release/pgtail-windows-x86_64.zip
            release/pgtail-windows-x86_64.zip.sha256
            release/pgtail-windows-x86_64.msi
            release/pgtail-windows-x86_64.msi.sha256
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check workflow timing
        run: |
          end_time=$(date +%s)
          start_time=${{ steps.timing.outputs.start_time }}
          duration=$((end_time - start_time))
          max_duration=$((15 * 60))  # 15 minutes in seconds

          echo "Release job duration: ${duration}s"
          if [ "$duration" -gt "$max_duration" ]; then
            echo "::warning::Release job exceeded 15 minute target: ${duration}s"
          else
            echo "Release job completed within target time."
          fi

  # Update Homebrew formula with new version and checksums
  update-homebrew:
    needs: release
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Extract version from tag
        id: version
        run: |
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Updating Homebrew formula to version $VERSION"

      - name: Clone homebrew-tap repository
        run: |
          git clone https://x-access-token:${{ secrets.HOMEBREW_TAP_TOKEN }}@github.com/willibrandon/homebrew-tap.git
          cd homebrew-tap
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update formula with new version and checksums
        run: |
          cd homebrew-tap
          VERSION="${{ steps.version.outputs.version }}"

          # Update version
          sed -i "s/version \".*\"/version \"$VERSION\"/" Formula/pgtail.rb

          # Update SHA256 checksums using Python for reliable replacement
          python3 << 'EOF'
          import re

          with open('Formula/pgtail.rb', 'r') as f:
              content = f.read()

          # Define SHA256 values from release artifacts
          shas = {
              'macos-arm64': '${{ needs.release.outputs.sha256_macos_arm64 }}',
              'macos-x86_64': '${{ needs.release.outputs.sha256_macos_x86_64 }}',
              'linux-arm64': '${{ needs.release.outputs.sha256_linux_arm64 }}',
              'linux-x86_64': '${{ needs.release.outputs.sha256_linux_x86_64 }}',
          }

          # Replace SHA256 placeholders for each platform
          # Pattern matches: sha256 "PLACEHOLDER" or sha256 "abc123..."
          for platform, sha in shas.items():
              # Match the url line followed by sha256 line for each platform
              pattern = rf'(url "https://github\.com/willibrandon/pgtail/releases/download/v#\{{version\}}/pgtail-{platform}\.tar\.gz"\s+sha256 ")[^"]*(")'
              content = re.sub(pattern, rf'\g<1>{sha}\2', content)

          with open('Formula/pgtail.rb', 'w') as f:
              f.write(content)
          EOF

          echo "Updated Formula/pgtail.rb:"
          cat Formula/pgtail.rb

      - name: Commit and push changes
        run: |
          cd homebrew-tap
          VERSION="${{ steps.version.outputs.version }}"

          git add Formula/pgtail.rb
          git diff --staged --quiet || git commit -m "Update pgtail to $VERSION"
          git push origin main

  # Update winget manifest and submit PR
  update-winget:
    needs: release
    runs-on: windows-latest
    timeout-minutes: 30
    steps:
      - name: Extract version from tag
        id: version
        shell: pwsh
        run: |
          $version = "${{ github.ref_name }}" -replace '^v', ''
          echo "version=$version" >> $env:GITHUB_OUTPUT
          echo "Updating winget manifest to version $version"

      - name: Check if package exists in winget-pkgs
        id: check
        shell: pwsh
        run: |
          $response = Invoke-WebRequest -Uri "https://api.github.com/repos/microsoft/winget-pkgs/contents/manifests/w/willibrandon/pgtail" -Method Head -SkipHttpErrorCheck
          if ($response.StatusCode -eq 200) {
            echo "exists=true" >> $env:GITHUB_OUTPUT
          } else {
            echo "exists=false" >> $env:GITHUB_OUTPUT
            echo "Package not yet in winget-pkgs, skipping update"
          }

      - name: Install wingetcreate
        if: steps.check.outputs.exists == 'true'
        shell: pwsh
        run: |
          Invoke-WebRequest -Uri https://aka.ms/wingetcreate/latest -OutFile wingetcreate.exe

      - name: Generate winget manifest
        if: steps.check.outputs.exists == 'true'
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.version }}"
          $url = "https://github.com/willibrandon/pgtail/releases/download/v$version/pgtail-windows-x86_64.msi"

          .\wingetcreate.exe update willibrandon.pgtail `
            --version $version `
            --urls $url `
            --out manifests

          # Add ReleaseDate to installer manifest
          $installerPath = "manifests/w/willibrandon/pgtail/$version/willibrandon.pgtail.installer.yaml"
          $content = Get-Content $installerPath -Raw
          $releaseDate = Get-Date -Format "yyyy-MM-dd"
          $content = $content -replace "(ManifestType: installer)", "ReleaseDate: $releaseDate`n`$1"
          Set-Content $installerPath $content -NoNewline

          # Add ReleaseNotesUrl to locale manifest
          $localePath = "manifests/w/willibrandon/pgtail/$version/willibrandon.pgtail.locale.en-US.yaml"
          $content = Get-Content $localePath -Raw
          $content = $content -replace "(ManifestType: defaultLocale)", "ReleaseNotesUrl: https://github.com/willibrandon/pgtail/releases/tag/v$version`n`$1"
          Set-Content $localePath $content -NoNewline

      - name: Submit winget PR via GitHub API
        if: steps.check.outputs.exists == 'true'
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.WINGET_PKGS_TOKEN }}
        run: |
          $version = "${{ steps.version.outputs.version }}"
          $branch = "pgtail-$version"
          $manifestDir = "manifests/w/willibrandon/pgtail/$version"

          # Sync fork with upstream first
          Write-Host "Syncing fork with upstream..."
          gh api repos/willibrandon/winget-pkgs/merge-upstream -X POST -f branch="master"

          # Get fork's master commit SHA (now synced with upstream)
          $forkRef = gh api repos/willibrandon/winget-pkgs/git/ref/heads/master --jq '.object.sha'
          Write-Host "Fork master SHA: $forkRef"

          # Get the tree SHA for that commit
          $baseTreeSha = gh api "repos/willibrandon/winget-pkgs/git/commits/$forkRef" --jq '.tree.sha'
          Write-Host "Base tree SHA: $baseTreeSha"

          # Create blobs for each manifest file and build tree entries
          $treeEntries = [System.Collections.ArrayList]@()
          Get-ChildItem -Path "manifests" -Recurse -File | ForEach-Object {
            $content = [Convert]::ToBase64String([System.IO.File]::ReadAllBytes($_.FullName))
            $blobResponse = gh api repos/willibrandon/winget-pkgs/git/blobs -X POST -f content="$content" -f encoding="base64"
            $blobSha = $blobResponse | ConvertFrom-Json | Select-Object -ExpandProperty sha
            $path = "$manifestDir/$($_.Name)"
            Write-Host "Created blob for $path : $blobSha"
            [void]$treeEntries.Add(@{path=$path; mode="100644"; type="blob"; sha=$blobSha})
          }

          # Create new tree with manifest files added
          $treeData = @{base_tree=$baseTreeSha; tree=$treeEntries.ToArray()}
          $treeJson = $treeData | ConvertTo-Json -Depth 10
          Write-Host "Tree JSON: $treeJson"
          $treeJson | Out-File -FilePath tree.json -Encoding utf8NoBOM
          $newTree = gh api repos/willibrandon/winget-pkgs/git/trees -X POST --input tree.json
          $newTreeSha = $newTree | ConvertFrom-Json | Select-Object -ExpandProperty sha
          Write-Host "New tree SHA: $newTreeSha"

          # Create commit
          $commitJson = @{
            message="Update willibrandon.pgtail to $version"
            tree=$newTreeSha
            parents=@($forkRef)
          } | ConvertTo-Json -Compress
          $commitJson | Out-File -FilePath commit.json -Encoding utf8
          $newCommit = gh api repos/willibrandon/winget-pkgs/git/commits -X POST --input commit.json
          $newCommitSha = $newCommit | ConvertFrom-Json | Select-Object -ExpandProperty sha
          Write-Host "New commit SHA: $newCommitSha"

          # Create or update branch reference
          $refExists = gh api "repos/willibrandon/winget-pkgs/git/ref/heads/$branch" 2>$null
          if ($LASTEXITCODE -eq 0) {
            gh api "repos/willibrandon/winget-pkgs/git/refs/heads/$branch" -X PATCH -f sha="$newCommitSha" -F force=true
          } else {
            gh api repos/willibrandon/winget-pkgs/git/refs -X POST -f ref="refs/heads/$branch" -f sha="$newCommitSha"
          }
          Write-Host "Branch $branch updated to $newCommitSha"

          # Create PR
          gh pr create `
            --repo microsoft/winget-pkgs `
            --base master `
            --head willibrandon:$branch `
            --title "Update willibrandon.pgtail to $version" `
            --body "## Description`n`nUpdate pgtail to version $version`n`n## Release notes`n`nhttps://github.com/willibrandon/pgtail/releases/tag/v$version"

  # Notify on failure
  notify-failure:
    needs: [build-unix, build-windows, release, update-homebrew, update-winget]
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: Create failure issue
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const runUrl = `https://github.com/${owner}/${repo}/actions/runs/${context.runId}`;
            const tag = context.ref.replace('refs/tags/', '');

            await github.rest.issues.create({
              owner,
              repo,
              title: `Release ${tag} failed`,
              body: `The release workflow for ${tag} failed.\n\nSee the [workflow run](${runUrl}) for details.`,
              labels: ['bug', 'release']
            });
